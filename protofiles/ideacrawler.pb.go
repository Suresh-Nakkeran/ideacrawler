/*************************************************************************
 *
 * Copyright 2018 Ideas2IT Technology Services Private Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ***********************************************************************/

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: protofiles/ideacrawler.proto

package protofiles

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//Subscription type
type SubType int32

const (
	// crawler will remember sequence number of each page stored, so we can start back exactly where we left off
	SubType_SEQNUM SubType = 0
	// if we know only the time when we left off,  or if we want to start reading from a certain day's run
	SubType_DATETIME SubType = 1
)

var SubType_name = map[int32]string{
	0: "SEQNUM",
	1: "DATETIME",
}

var SubType_value = map[string]int32{
	"SEQNUM":   0,
	"DATETIME": 1,
}

func (x SubType) String() string {
	return proto.EnumName(SubType_name, int32(x))
}

func (SubType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bda11c783d819bdd, []int{0}
}

type PageReqType int32

const (
	PageReqType_GET PageReqType = 0
	// Sends a HEAD request to first identify page is text/html before downloading
	// If we are unsure link will send back large gzip file, etc. which we want to
	// avoid.
	PageReqType_HEAD      PageReqType = 1
	PageReqType_BUILTINJS PageReqType = 2
	PageReqType_JSCRIPT   PageReqType = 3
)

var PageReqType_name = map[int32]string{
	0: "GET",
	1: "HEAD",
	2: "BUILTINJS",
	3: "JSCRIPT",
}

var PageReqType_value = map[string]int32{
	"GET":       0,
	"HEAD":      1,
	"BUILTINJS": 2,
	"JSCRIPT":   3,
}

func (x PageReqType) String() string {
	return proto.EnumName(PageReqType_name, int32(x))
}

func (PageReqType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bda11c783d819bdd, []int{1}
}

type Status struct {
	Success              bool     `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error                string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_bda11c783d819bdd, []int{0}
}

func (m *Status) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Status.Unmarshal(m, b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Status.Marshal(b, m, deterministic)
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return xxx_messageInfo_Status.Size(m)
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *Status) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type KVP struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVP) Reset()         { *m = KVP{} }
func (m *KVP) String() string { return proto.CompactTextString(m) }
func (*KVP) ProtoMessage()    {}
func (*KVP) Descriptor() ([]byte, []int) {
	return fileDescriptor_bda11c783d819bdd, []int{1}
}

func (m *KVP) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KVP.Unmarshal(m, b)
}
func (m *KVP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KVP.Marshal(b, m, deterministic)
}
func (m *KVP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVP.Merge(m, src)
}
func (m *KVP) XXX_Size() int {
	return xxx_messageInfo_KVP.Size(m)
}
func (m *KVP) XXX_DiscardUnknown() {
	xxx_messageInfo_KVP.DiscardUnknown(m)
}

var xxx_messageInfo_KVP proto.InternalMessageInfo

func (m *KVP) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KVP) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type DomainOpt struct {
	SeedUrl string `protobuf:"bytes,1,opt,name=seedUrl,proto3" json:"seedUrl,omitempty"`
	// crawl delay in seconds
	MinDelay int32 `protobuf:"varint,2,opt,name=minDelay,proto3" json:"minDelay,omitempty"`
	MaxDelay int32 `protobuf:"varint,3,opt,name=maxDelay,proto3" json:"maxDelay,omitempty"`
	// don't follow any pages,  just send back responses for the received URLs.
	NoFollow bool `protobuf:"varint,4,opt,name=noFollow,proto3" json:"noFollow,omitempty"`
	// only pages matching reqUrlRegexp will be shipped back to the client.
	// only matching pages will be saved to s3 as well.
	CallbackUrlRegexp string `protobuf:"bytes,5,opt,name=callbackUrlRegexp,proto3" json:"callbackUrlRegexp,omitempty"`
	// only pages matching followUrlRegexp will be followed and sublinks added to fetcher.
	FollowUrlRegexp       string `protobuf:"bytes,6,opt,name=followUrlRegexp,proto3" json:"followUrlRegexp,omitempty"`
	MaxConcurrentRequests int32  `protobuf:"varint,7,opt,name=maxConcurrentRequests,proto3" json:"maxConcurrentRequests,omitempty"`
	//TODO
	Useragent string `protobuf:"bytes,8,opt,name=useragent,proto3" json:"useragent,omitempty"`
	Impolite  bool   `protobuf:"varint,9,opt,name=impolite,proto3" json:"impolite,omitempty"`
	//TODO
	Depth int32 `protobuf:"varint,10,opt,name=depth,proto3" json:"depth,omitempty"`
	// Callback check order -
	//   (1) - callbackUrlRegexp
	//   (2) - callbackXpathMatch
	//   (3) - callbackXpathRegexp
	//  Any one has to match.
	// provide multiple xpaths as keys and expected values as value.  Pages are
	// sent back to client only if all values are found in page.
	CallbackXpathMatch  []*KVP `protobuf:"bytes,14,rep,name=callbackXpathMatch,proto3" json:"callbackXpathMatch,omitempty"`
	CallbackXpathRegexp []*KVP `protobuf:"bytes,15,rep,name=callbackXpathRegexp,proto3" json:"callbackXpathRegexp,omitempty"`
	//  in seconds, it is the time to wait for a new
	// page, before stopping the job; affects workerIdleTTL of fetchbot.
	// min value is 600, it is also default.
	MaxIdleTime        int32    `protobuf:"varint,16,opt,name=maxIdleTime,proto3" json:"maxIdleTime,omitempty"`
	FollowOtherDomains bool     `protobuf:"varint,17,opt,name=followOtherDomains,proto3" json:"followOtherDomains,omitempty"`
	KeepDomains        []string `protobuf:"bytes,18,rep,name=keepDomains,proto3" json:"keepDomains,omitempty"`
	DropDomains        []string `protobuf:"bytes,19,rep,name=dropDomains,proto3" json:"dropDomains,omitempty"`
	DomainDropPriority bool     `protobuf:"varint,20,opt,name=domainDropPriority,proto3" json:"domainDropPriority,omitempty"`
	// safe url normalizations happen by default. below is only for a few unsafe ones.
	// for list of safe normalizations: https://github.com/PuerkitoBio/purell/blob/master/purell.go#L59
	// remove index.php, etc,  fragments #section, +FlagsUsuallySafeGreedy from above link
	UnsafeNormalizeURL bool `protobuf:"varint,21,opt,name=unsafeNormalizeURL,proto3" json:"unsafeNormalizeURL,omitempty"`
	Login              bool `protobuf:"varint,22,opt,name=login,proto3" json:"login,omitempty"`
	// currently not possible, assumes false. uses chrome debugging protocol directly.
	LoginUsingSelenium bool   `protobuf:"varint,23,opt,name=loginUsingSelenium,proto3" json:"loginUsingSelenium,omitempty"`
	LoginUrl           string `protobuf:"bytes,24,opt,name=loginUrl,proto3" json:"loginUrl,omitempty"`
	// for username, password fields, other form data to send on post request
	LoginPayload []*KVP `protobuf:"bytes,25,rep,name=loginPayload,proto3" json:"loginPayload,omitempty"`
	// if there are hidden fields in the page that need to be scraped before login
	LoginParseFields bool `protobuf:"varint,26,opt,name=loginParseFields,proto3" json:"loginParseFields,omitempty"`
	// key is key of hidden fields to parse from form, value is the xpath of field to scrape.
	LoginParseXpath []*KVP `protobuf:"bytes,27,rep,name=loginParseXpath,proto3" json:"loginParseXpath,omitempty"`
	// to check if login succeeded, provide xpath as key, and expected value as value.
	// for example,  after login, xpath of top right corner,  and username as value.
	// if the xpath is not there of if there is no value match,  then we probably didn't login.
	LoginSuccessCheck *KVP `protobuf:"bytes,28,opt,name=loginSuccessCheck,proto3" json:"loginSuccessCheck,omitempty"`
	// checks login state after downloading each page, using check defined in 'loginSuccessCheck'
	CheckLoginAfterEachPage bool `protobuf:"varint,29,opt,name=checkLoginAfterEachPage,proto3" json:"checkLoginAfterEachPage,omitempty"`
	// javascript for login in chrome browser.
	LoginJS string `protobuf:"bytes,30,opt,name=loginJS,proto3" json:"loginJS,omitempty"`
	// whether to use chrome, location of chrome binary
	Chrome       bool   `protobuf:"varint,31,opt,name=chrome,proto3" json:"chrome,omitempty"`
	ChromeBinary string `protobuf:"bytes,32,opt,name=chromeBinary,proto3" json:"chromeBinary,omitempty"`
	DomLoadTime  int32  `protobuf:"varint,33,opt,name=domLoadTime,proto3" json:"domLoadTime,omitempty"`
	// check if this network interface is still active before every request.
	NetworkIface       string `protobuf:"bytes,34,opt,name=networkIface,proto3" json:"networkIface,omitempty"`
	CancelOnDisconnect bool   `protobuf:"varint,35,opt,name=cancelOnDisconnect,proto3" json:"cancelOnDisconnect,omitempty"`
	// if true,  sends a HEAD request first ensure content is text/html before sending GET request.
	CheckContent bool `protobuf:"varint,36,opt,name=checkContent,proto3" json:"checkContent,omitempty"`
	// if prefetch flag is true, downloads resources like img, css, png, svg, js associated with the actual page to mimic browser behaviour.
	Prefetch bool `protobuf:"varint,37,opt,name=prefetch,proto3" json:"prefetch,omitempty"`
	// pages matching anchor text regexp will be shipped back to the client.
	CallbackAnchorTextRegexp string `protobuf:"bytes,39,opt,name=callbackAnchorTextRegexp,proto3" json:"callbackAnchorTextRegexp,omitempty"`
	// If true ships the page at depth 0, else only pattern matched urls are shipped
	CallbackSeedUrl      bool     `protobuf:"varint,40,opt,name=callbackSeedUrl,proto3" json:"callbackSeedUrl,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DomainOpt) Reset()         { *m = DomainOpt{} }
func (m *DomainOpt) String() string { return proto.CompactTextString(m) }
func (*DomainOpt) ProtoMessage()    {}
func (*DomainOpt) Descriptor() ([]byte, []int) {
	return fileDescriptor_bda11c783d819bdd, []int{2}
}

func (m *DomainOpt) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DomainOpt.Unmarshal(m, b)
}
func (m *DomainOpt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DomainOpt.Marshal(b, m, deterministic)
}
func (m *DomainOpt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainOpt.Merge(m, src)
}
func (m *DomainOpt) XXX_Size() int {
	return xxx_messageInfo_DomainOpt.Size(m)
}
func (m *DomainOpt) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainOpt.DiscardUnknown(m)
}

var xxx_messageInfo_DomainOpt proto.InternalMessageInfo

func (m *DomainOpt) GetSeedUrl() string {
	if m != nil {
		return m.SeedUrl
	}
	return ""
}

func (m *DomainOpt) GetMinDelay() int32 {
	if m != nil {
		return m.MinDelay
	}
	return 0
}

func (m *DomainOpt) GetMaxDelay() int32 {
	if m != nil {
		return m.MaxDelay
	}
	return 0
}

func (m *DomainOpt) GetNoFollow() bool {
	if m != nil {
		return m.NoFollow
	}
	return false
}

func (m *DomainOpt) GetCallbackUrlRegexp() string {
	if m != nil {
		return m.CallbackUrlRegexp
	}
	return ""
}

func (m *DomainOpt) GetFollowUrlRegexp() string {
	if m != nil {
		return m.FollowUrlRegexp
	}
	return ""
}

func (m *DomainOpt) GetMaxConcurrentRequests() int32 {
	if m != nil {
		return m.MaxConcurrentRequests
	}
	return 0
}

func (m *DomainOpt) GetUseragent() string {
	if m != nil {
		return m.Useragent
	}
	return ""
}

func (m *DomainOpt) GetImpolite() bool {
	if m != nil {
		return m.Impolite
	}
	return false
}

func (m *DomainOpt) GetDepth() int32 {
	if m != nil {
		return m.Depth
	}
	return 0
}

func (m *DomainOpt) GetCallbackXpathMatch() []*KVP {
	if m != nil {
		return m.CallbackXpathMatch
	}
	return nil
}

func (m *DomainOpt) GetCallbackXpathRegexp() []*KVP {
	if m != nil {
		return m.CallbackXpathRegexp
	}
	return nil
}

func (m *DomainOpt) GetMaxIdleTime() int32 {
	if m != nil {
		return m.MaxIdleTime
	}
	return 0
}

func (m *DomainOpt) GetFollowOtherDomains() bool {
	if m != nil {
		return m.FollowOtherDomains
	}
	return false
}

func (m *DomainOpt) GetKeepDomains() []string {
	if m != nil {
		return m.KeepDomains
	}
	return nil
}

func (m *DomainOpt) GetDropDomains() []string {
	if m != nil {
		return m.DropDomains
	}
	return nil
}

func (m *DomainOpt) GetDomainDropPriority() bool {
	if m != nil {
		return m.DomainDropPriority
	}
	return false
}

func (m *DomainOpt) GetUnsafeNormalizeURL() bool {
	if m != nil {
		return m.UnsafeNormalizeURL
	}
	return false
}

func (m *DomainOpt) GetLogin() bool {
	if m != nil {
		return m.Login
	}
	return false
}

func (m *DomainOpt) GetLoginUsingSelenium() bool {
	if m != nil {
		return m.LoginUsingSelenium
	}
	return false
}

func (m *DomainOpt) GetLoginUrl() string {
	if m != nil {
		return m.LoginUrl
	}
	return ""
}

func (m *DomainOpt) GetLoginPayload() []*KVP {
	if m != nil {
		return m.LoginPayload
	}
	return nil
}

func (m *DomainOpt) GetLoginParseFields() bool {
	if m != nil {
		return m.LoginParseFields
	}
	return false
}

func (m *DomainOpt) GetLoginParseXpath() []*KVP {
	if m != nil {
		return m.LoginParseXpath
	}
	return nil
}

func (m *DomainOpt) GetLoginSuccessCheck() *KVP {
	if m != nil {
		return m.LoginSuccessCheck
	}
	return nil
}

func (m *DomainOpt) GetCheckLoginAfterEachPage() bool {
	if m != nil {
		return m.CheckLoginAfterEachPage
	}
	return false
}

func (m *DomainOpt) GetLoginJS() string {
	if m != nil {
		return m.LoginJS
	}
	return ""
}

func (m *DomainOpt) GetChrome() bool {
	if m != nil {
		return m.Chrome
	}
	return false
}

func (m *DomainOpt) GetChromeBinary() string {
	if m != nil {
		return m.ChromeBinary
	}
	return ""
}

func (m *DomainOpt) GetDomLoadTime() int32 {
	if m != nil {
		return m.DomLoadTime
	}
	return 0
}

func (m *DomainOpt) GetNetworkIface() string {
	if m != nil {
		return m.NetworkIface
	}
	return ""
}

func (m *DomainOpt) GetCancelOnDisconnect() bool {
	if m != nil {
		return m.CancelOnDisconnect
	}
	return false
}

func (m *DomainOpt) GetCheckContent() bool {
	if m != nil {
		return m.CheckContent
	}
	return false
}

func (m *DomainOpt) GetPrefetch() bool {
	if m != nil {
		return m.Prefetch
	}
	return false
}

func (m *DomainOpt) GetCallbackAnchorTextRegexp() string {
	if m != nil {
		return m.CallbackAnchorTextRegexp
	}
	return ""
}

func (m *DomainOpt) GetCallbackSeedUrl() bool {
	if m != nil {
		return m.CallbackSeedUrl
	}
	return false
}

type Subscription struct {
	Subcode              string               `protobuf:"bytes,1,opt,name=subcode,proto3" json:"subcode,omitempty"`
	Domainname           string               `protobuf:"bytes,2,opt,name=domainname,proto3" json:"domainname,omitempty"`
	Subtype              SubType              `protobuf:"varint,3,opt,name=subtype,proto3,enum=protofiles.SubType" json:"subtype,omitempty"`
	Seqnum               int32                `protobuf:"varint,4,opt,name=seqnum,proto3" json:"seqnum,omitempty"`
	Datetime             *timestamp.Timestamp `protobuf:"bytes,5,opt,name=datetime,proto3" json:"datetime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Subscription) Reset()         { *m = Subscription{} }
func (m *Subscription) String() string { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()    {}
func (*Subscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_bda11c783d819bdd, []int{3}
}

func (m *Subscription) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Subscription.Unmarshal(m, b)
}
func (m *Subscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Subscription.Marshal(b, m, deterministic)
}
func (m *Subscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subscription.Merge(m, src)
}
func (m *Subscription) XXX_Size() int {
	return xxx_messageInfo_Subscription.Size(m)
}
func (m *Subscription) XXX_DiscardUnknown() {
	xxx_messageInfo_Subscription.DiscardUnknown(m)
}

var xxx_messageInfo_Subscription proto.InternalMessageInfo

func (m *Subscription) GetSubcode() string {
	if m != nil {
		return m.Subcode
	}
	return ""
}

func (m *Subscription) GetDomainname() string {
	if m != nil {
		return m.Domainname
	}
	return ""
}

func (m *Subscription) GetSubtype() SubType {
	if m != nil {
		return m.Subtype
	}
	return SubType_SEQNUM
}

func (m *Subscription) GetSeqnum() int32 {
	if m != nil {
		return m.Seqnum
	}
	return 0
}

func (m *Subscription) GetDatetime() *timestamp.Timestamp {
	if m != nil {
		return m.Datetime
	}
	return nil
}

type PageRequest struct {
	Sub                  *Subscription `protobuf:"bytes,1,opt,name=sub,proto3" json:"sub,omitempty"`
	Reqtype              PageReqType   `protobuf:"varint,2,opt,name=reqtype,proto3,enum=protofiles.PageReqType" json:"reqtype,omitempty"`
	Url                  string        `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	Js                   string        `protobuf:"bytes,4,opt,name=js,proto3" json:"js,omitempty"`
	NoCallback           bool          `protobuf:"varint,5,opt,name=noCallback,proto3" json:"noCallback,omitempty"`
	MetaStr              string        `protobuf:"bytes,6,opt,name=metaStr,proto3" json:"metaStr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PageRequest) Reset()         { *m = PageRequest{} }
func (m *PageRequest) String() string { return proto.CompactTextString(m) }
func (*PageRequest) ProtoMessage()    {}
func (*PageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bda11c783d819bdd, []int{4}
}

func (m *PageRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PageRequest.Unmarshal(m, b)
}
func (m *PageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PageRequest.Marshal(b, m, deterministic)
}
func (m *PageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PageRequest.Merge(m, src)
}
func (m *PageRequest) XXX_Size() int {
	return xxx_messageInfo_PageRequest.Size(m)
}
func (m *PageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PageRequest proto.InternalMessageInfo

func (m *PageRequest) GetSub() *Subscription {
	if m != nil {
		return m.Sub
	}
	return nil
}

func (m *PageRequest) GetReqtype() PageReqType {
	if m != nil {
		return m.Reqtype
	}
	return PageReqType_GET
}

func (m *PageRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *PageRequest) GetJs() string {
	if m != nil {
		return m.Js
	}
	return ""
}

func (m *PageRequest) GetNoCallback() bool {
	if m != nil {
		return m.NoCallback
	}
	return false
}

func (m *PageRequest) GetMetaStr() string {
	if m != nil {
		return m.MetaStr
	}
	return ""
}

type PageHTML struct {
	Success              bool          `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error                string        `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Sub                  *Subscription `protobuf:"bytes,3,opt,name=sub,proto3" json:"sub,omitempty"`
	Url                  string        `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	Httpstatuscode       int32         `protobuf:"varint,5,opt,name=httpstatuscode,proto3" json:"httpstatuscode,omitempty"`
	Content              []byte        `protobuf:"bytes,6,opt,name=content,proto3" json:"content,omitempty"`
	MetaStr              string        `protobuf:"bytes,7,opt,name=metaStr,proto3" json:"metaStr,omitempty"`
	UrlDepth             int32         `protobuf:"varint,8,opt,name=urlDepth,proto3" json:"urlDepth,omitempty"`
	AnchorText           string        `protobuf:"bytes,9,opt,name=anchorText,proto3" json:"anchorText,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PageHTML) Reset()         { *m = PageHTML{} }
func (m *PageHTML) String() string { return proto.CompactTextString(m) }
func (*PageHTML) ProtoMessage()    {}
func (*PageHTML) Descriptor() ([]byte, []int) {
	return fileDescriptor_bda11c783d819bdd, []int{5}
}

func (m *PageHTML) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PageHTML.Unmarshal(m, b)
}
func (m *PageHTML) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PageHTML.Marshal(b, m, deterministic)
}
func (m *PageHTML) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PageHTML.Merge(m, src)
}
func (m *PageHTML) XXX_Size() int {
	return xxx_messageInfo_PageHTML.Size(m)
}
func (m *PageHTML) XXX_DiscardUnknown() {
	xxx_messageInfo_PageHTML.DiscardUnknown(m)
}

var xxx_messageInfo_PageHTML proto.InternalMessageInfo

func (m *PageHTML) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *PageHTML) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *PageHTML) GetSub() *Subscription {
	if m != nil {
		return m.Sub
	}
	return nil
}

func (m *PageHTML) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *PageHTML) GetHttpstatuscode() int32 {
	if m != nil {
		return m.Httpstatuscode
	}
	return 0
}

func (m *PageHTML) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *PageHTML) GetMetaStr() string {
	if m != nil {
		return m.MetaStr
	}
	return ""
}

func (m *PageHTML) GetUrlDepth() int32 {
	if m != nil {
		return m.UrlDepth
	}
	return 0
}

func (m *PageHTML) GetAnchorText() string {
	if m != nil {
		return m.AnchorText
	}
	return ""
}

type UrlList struct {
	Url                  []string `protobuf:"bytes,1,rep,name=url,proto3" json:"url,omitempty"`
	MetaStr              string   `protobuf:"bytes,2,opt,name=metaStr,proto3" json:"metaStr,omitempty"`
	UrlDepth             int32    `protobuf:"varint,3,opt,name=urlDepth,proto3" json:"urlDepth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UrlList) Reset()         { *m = UrlList{} }
func (m *UrlList) String() string { return proto.CompactTextString(m) }
func (*UrlList) ProtoMessage()    {}
func (*UrlList) Descriptor() ([]byte, []int) {
	return fileDescriptor_bda11c783d819bdd, []int{6}
}

func (m *UrlList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UrlList.Unmarshal(m, b)
}
func (m *UrlList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UrlList.Marshal(b, m, deterministic)
}
func (m *UrlList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrlList.Merge(m, src)
}
func (m *UrlList) XXX_Size() int {
	return xxx_messageInfo_UrlList.Size(m)
}
func (m *UrlList) XXX_DiscardUnknown() {
	xxx_messageInfo_UrlList.DiscardUnknown(m)
}

var xxx_messageInfo_UrlList proto.InternalMessageInfo

func (m *UrlList) GetUrl() []string {
	if m != nil {
		return m.Url
	}
	return nil
}

func (m *UrlList) GetMetaStr() string {
	if m != nil {
		return m.MetaStr
	}
	return ""
}

func (m *UrlList) GetUrlDepth() int32 {
	if m != nil {
		return m.UrlDepth
	}
	return 0
}

func init() {
	proto.RegisterEnum("protofiles.SubType", SubType_name, SubType_value)
	proto.RegisterEnum("protofiles.PageReqType", PageReqType_name, PageReqType_value)
	proto.RegisterType((*Status)(nil), "protofiles.Status")
	proto.RegisterType((*KVP)(nil), "protofiles.KVP")
	proto.RegisterType((*DomainOpt)(nil), "protofiles.DomainOpt")
	proto.RegisterType((*Subscription)(nil), "protofiles.Subscription")
	proto.RegisterType((*PageRequest)(nil), "protofiles.PageRequest")
	proto.RegisterType((*PageHTML)(nil), "protofiles.PageHTML")
	proto.RegisterType((*UrlList)(nil), "protofiles.UrlList")
}

func init() { proto.RegisterFile("protofiles/ideacrawler.proto", fileDescriptor_bda11c783d819bdd) }

var fileDescriptor_bda11c783d819bdd = []byte{
	// 1225 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdb, 0x72, 0x1a, 0x47,
	0x13, 0x16, 0x60, 0x09, 0x18, 0xf4, 0x4b, 0x78, 0x7c, 0x9a, 0x5f, 0x71, 0x6c, 0x82, 0x73, 0xa0,
	0x54, 0x31, 0x4e, 0xe4, 0x54, 0xca, 0x39, 0x55, 0x0a, 0x03, 0xb6, 0x91, 0x91, 0x2d, 0x2f, 0xe0,
	0xca, 0xed, 0xb0, 0xdb, 0xc0, 0x5a, 0xbb, 0x3b, 0xeb, 0xd9, 0xd9, 0x48, 0xf8, 0x29, 0x72, 0x91,
	0xa7, 0xc9, 0x0b, 0x24, 0x8f, 0x95, 0x9a, 0x9e, 0x5d, 0xb4, 0x1c, 0x94, 0x4a, 0xee, 0xa6, 0xbf,
	0xfe, 0xa6, 0x0f, 0xd3, 0xbd, 0xdd, 0x4b, 0xee, 0x86, 0x52, 0x28, 0x31, 0x71, 0x3d, 0x88, 0x1e,
	0xb9, 0x0e, 0x70, 0x5b, 0xf2, 0x73, 0x0f, 0x64, 0x13, 0x61, 0x4a, 0x2e, 0xb5, 0x07, 0xf7, 0xa7,
	0x42, 0x4c, 0x3d, 0x78, 0x84, 0xd0, 0x38, 0x9e, 0x3c, 0x52, 0xae, 0x0f, 0x91, 0xe2, 0x7e, 0x68,
	0xc8, 0xf5, 0x27, 0x64, 0x67, 0xa0, 0xb8, 0x8a, 0x23, 0xca, 0x48, 0x31, 0x8a, 0x6d, 0x1b, 0xa2,
	0x88, 0xe5, 0x6a, 0xb9, 0x46, 0xc9, 0x4a, 0x45, 0x7a, 0x93, 0x6c, 0x83, 0x94, 0x42, 0xb2, 0x7c,
	0x2d, 0xd7, 0x28, 0x5b, 0x46, 0xa8, 0x3f, 0x24, 0x85, 0x97, 0x6f, 0x4f, 0x69, 0x95, 0x14, 0xce,
	0x60, 0x8e, 0x57, 0xca, 0x96, 0x3e, 0x6a, 0xfa, 0xaf, 0xdc, 0x8b, 0x21, 0xa5, 0xa3, 0x50, 0xff,
	0xa3, 0x42, 0xca, 0x1d, 0xe1, 0x73, 0x37, 0x78, 0x1d, 0x2a, 0x74, 0x06, 0xe0, 0x8c, 0xa4, 0x97,
	0xdc, 0x4c, 0x45, 0x7a, 0x40, 0x4a, 0xbe, 0x1b, 0x74, 0xc0, 0xe3, 0x73, 0x34, 0xb0, 0x6d, 0x2d,
	0x64, 0xd4, 0xf1, 0x0b, 0xa3, 0x2b, 0x24, 0xba, 0x44, 0xd6, 0xba, 0x40, 0x3c, 0x13, 0x9e, 0x27,
	0xce, 0xd9, 0x35, 0x8c, 0x7f, 0x21, 0xd3, 0x2f, 0xc9, 0x75, 0x9b, 0x7b, 0xde, 0x98, 0xdb, 0x67,
	0x23, 0xe9, 0x59, 0x30, 0x85, 0x8b, 0x90, 0x6d, 0xa3, 0xdf, 0x75, 0x05, 0x6d, 0x90, 0xfd, 0x09,
	0xde, 0xbb, 0xe4, 0xee, 0x20, 0x77, 0x15, 0xa6, 0xdf, 0x90, 0x5b, 0x3e, 0xbf, 0x68, 0x8b, 0xc0,
	0x8e, 0xa5, 0x84, 0x40, 0x59, 0xf0, 0x3e, 0x86, 0x48, 0x45, 0xac, 0x88, 0xc1, 0x6d, 0x56, 0xd2,
	0xbb, 0xa4, 0x1c, 0x47, 0x20, 0xf9, 0x14, 0x02, 0xc5, 0x4a, 0x68, 0xf9, 0x12, 0xd0, 0x79, 0xb8,
	0x7e, 0x28, 0x3c, 0x57, 0x01, 0x2b, 0x9b, 0x3c, 0x52, 0x59, 0xbf, 0xac, 0x03, 0xa1, 0x9a, 0x31,
	0x82, 0xf6, 0x8d, 0x40, 0x7f, 0x26, 0x34, 0x4d, 0xe2, 0x97, 0x90, 0xab, 0xd9, 0x09, 0x57, 0xf6,
	0x8c, 0xed, 0xd5, 0x0a, 0x8d, 0xca, 0xd1, 0x7e, 0xf3, 0xb2, 0x19, 0x9a, 0x2f, 0xdf, 0x9e, 0x5a,
	0x1b, 0xa8, 0xb4, 0x45, 0x6e, 0x2c, 0xa1, 0x49, 0xd2, 0xfb, 0x9b, 0x2d, 0x6c, 0xe2, 0xd2, 0x1a,
	0xa9, 0xf8, 0xfc, 0xa2, 0xe7, 0x78, 0x30, 0x74, 0x7d, 0x60, 0x55, 0x8c, 0x2f, 0x0b, 0xd1, 0x26,
	0xa1, 0xe6, 0xf9, 0x5e, 0xab, 0x19, 0x48, 0xd3, 0x09, 0x11, 0xbb, 0x8e, 0x19, 0x6e, 0xd0, 0x68,
	0x8b, 0x67, 0x00, 0x61, 0x4a, 0xa4, 0xb5, 0x42, 0xa3, 0x6c, 0x65, 0x21, 0xcd, 0x70, 0xa4, 0x58,
	0x30, 0x6e, 0x18, 0x46, 0x06, 0xd2, 0x3e, 0x1d, 0x3c, 0x76, 0xa4, 0x08, 0x4f, 0xa5, 0x2b, 0xa4,
	0xab, 0xe6, 0xec, 0xa6, 0xf1, 0xb9, 0xae, 0xd1, 0xfc, 0x38, 0x88, 0xf8, 0x04, 0x5e, 0x09, 0xe9,
	0x73, 0xcf, 0xfd, 0x00, 0x23, 0xab, 0xcf, 0x6e, 0x19, 0xfe, 0xba, 0x46, 0xd7, 0xc3, 0x13, 0x53,
	0x37, 0x60, 0xb7, 0x91, 0x62, 0x04, 0x6d, 0x05, 0x0f, 0xa3, 0xc8, 0x0d, 0xa6, 0x03, 0xf0, 0x20,
	0x70, 0x63, 0x9f, 0xdd, 0x31, 0x56, 0xd6, 0x35, 0xba, 0xe2, 0x06, 0x95, 0x1e, 0x63, 0xd8, 0x0e,
	0x0b, 0x99, 0x3e, 0x26, 0xbb, 0x78, 0x3e, 0xe5, 0x73, 0x4f, 0x70, 0x87, 0xfd, 0x7f, 0x73, 0x4d,
	0x96, 0x48, 0xf4, 0x90, 0x54, 0x13, 0x59, 0x46, 0xf0, 0xcc, 0x05, 0xcf, 0x89, 0xd8, 0x01, 0xba,
	0x5f, 0xc3, 0xe9, 0x77, 0x64, 0xff, 0x12, 0xc3, 0x8a, 0xb2, 0x8f, 0x36, 0xfb, 0x58, 0xe5, 0xd1,
	0x9f, 0xc8, 0x75, 0x84, 0x06, 0x66, 0x4c, 0xb4, 0x67, 0x60, 0x9f, 0xb1, 0xbb, 0xb5, 0xdc, 0xa6,
	0xcb, 0xeb, 0x4c, 0xfa, 0x84, 0xdc, 0xb1, 0xf5, 0xa1, 0xaf, 0x35, 0xad, 0x89, 0x02, 0xd9, 0xe5,
	0xf6, 0xec, 0x94, 0x4f, 0x81, 0x7d, 0x8c, 0xc1, 0x5e, 0xa5, 0xd6, 0xc3, 0x03, 0xcd, 0x1d, 0x0f,
	0xd8, 0x3d, 0x33, 0x3c, 0x12, 0x91, 0xde, 0x26, 0x3b, 0xf6, 0x4c, 0x0a, 0x1f, 0xd8, 0x7d, 0x34,
	0x91, 0x48, 0xb4, 0x4e, 0x76, 0xcd, 0xe9, 0xa9, 0x1b, 0x70, 0x39, 0x67, 0x35, 0xbc, 0xb6, 0x84,
	0x61, 0x3b, 0x09, 0xbf, 0x2f, 0xb8, 0x83, 0x2d, 0xfc, 0x89, 0x69, 0xe1, 0x0c, 0xa4, 0xad, 0x04,
	0xa0, 0xce, 0x85, 0x3c, 0xeb, 0x4d, 0xb8, 0x0d, 0xac, 0x6e, 0xac, 0x64, 0x31, 0x5d, 0x7c, 0x9b,
	0x07, 0x36, 0x78, 0xaf, 0x83, 0x8e, 0x1b, 0xd9, 0x22, 0x08, 0xc0, 0x56, 0xec, 0x81, 0x29, 0xfe,
	0xba, 0xc6, 0x44, 0x06, 0xf6, 0x59, 0x5b, 0x04, 0x4a, 0xcf, 0x83, 0x4f, 0x91, 0xb9, 0x84, 0xe9,
	0x06, 0x09, 0x25, 0x4c, 0x40, 0x7f, 0xd6, 0x9f, 0x99, 0x91, 0x90, 0xca, 0xf4, 0x7b, 0xc2, 0xd2,
	0xef, 0xb1, 0x15, 0xd8, 0x33, 0x21, 0x87, 0x70, 0xa1, 0x92, 0x0f, 0xf8, 0x0b, 0x8c, 0xef, 0x4a,
	0xbd, 0x1e, 0x74, 0xa9, 0x6e, 0x90, 0x0c, 0xe3, 0x06, 0x9a, 0x5f, 0x85, 0xeb, 0x7f, 0xe6, 0xc8,
	0xee, 0x20, 0x1e, 0x47, 0xb6, 0x74, 0x43, 0xe5, 0x8a, 0xc0, 0x2c, 0x8b, 0xb1, 0x2d, 0x1c, 0x58,
	0xcc, 0x6f, 0x23, 0xd2, 0x7b, 0x84, 0x98, 0x2f, 0x2b, 0xe0, 0x7e, 0xba, 0x02, 0x32, 0x08, 0x7d,
	0x88, 0x37, 0xd5, 0x3c, 0x04, 0x1c, 0xe1, 0x7b, 0x47, 0x37, 0xb2, 0xbd, 0x32, 0x88, 0xc7, 0xc3,
	0x79, 0x08, 0x56, 0xca, 0xd1, 0x15, 0x8d, 0xe0, 0x7d, 0x10, 0xfb, 0x38, 0xd4, 0xb7, 0xad, 0x44,
	0xa2, 0xdf, 0x92, 0x92, 0xc3, 0x15, 0xe8, 0x75, 0x86, 0x93, 0xbc, 0x72, 0x74, 0xd0, 0x34, 0xbb,
	0xae, 0x99, 0xee, 0xba, 0xe6, 0x30, 0xdd, 0x75, 0xd6, 0x82, 0x5b, 0xff, 0x2b, 0x47, 0x2a, 0xba,
	0x89, 0x92, 0x69, 0x4c, 0x0f, 0x49, 0x21, 0x8a, 0xc7, 0x98, 0x44, 0xe5, 0x88, 0xad, 0x84, 0xb2,
	0xc8, 0xd7, 0xd2, 0x24, 0xfa, 0x35, 0x29, 0x4a, 0x78, 0x8f, 0xa1, 0xe7, 0x31, 0xf4, 0x3b, 0x59,
	0x7e, 0x62, 0xd5, 0x84, 0x9f, 0xf0, 0xf4, 0x76, 0x8c, 0xa5, 0x87, 0x99, 0x96, 0x2d, 0x7d, 0xa4,
	0x7b, 0x24, 0xff, 0x2e, 0xc2, 0x64, 0xca, 0x56, 0xfe, 0x5d, 0xa4, 0xdf, 0x2b, 0x10, 0xed, 0xe4,
	0xbd, 0x31, 0x95, 0x92, 0x95, 0x41, 0xf4, 0x4b, 0xfb, 0xa0, 0xf8, 0x40, 0xc9, 0x64, 0x0b, 0xa5,
	0x62, 0xfd, 0xb7, 0x3c, 0x29, 0x69, 0xa7, 0x2f, 0x86, 0x27, 0xfd, 0xff, 0xba, 0xbd, 0xd3, 0xbc,
	0x0b, 0xff, 0x26, 0xef, 0x24, 0x89, 0x6b, 0x97, 0x49, 0x7c, 0x4e, 0xf6, 0x66, 0x4a, 0x85, 0x11,
	0xfe, 0x39, 0x60, 0x17, 0x6c, 0x63, 0x75, 0x56, 0x50, 0x1d, 0x95, 0x9d, 0x34, 0xb6, 0x0e, 0x7e,
	0xd7, 0x4a, 0xc5, 0x6c, 0x5a, 0xc5, 0xa5, 0xb4, 0x74, 0xb7, 0xc7, 0xd2, 0xeb, 0xe0, 0x9e, 0x2b,
	0x99, 0x25, 0x9f, 0xca, 0xfa, 0xb1, 0xf8, 0xa2, 0x8b, 0x71, 0x3d, 0x96, 0xad, 0x0c, 0x52, 0x7f,
	0x43, 0x8a, 0x23, 0xe9, 0xf5, 0xdd, 0x48, 0xa5, 0x41, 0xe7, 0x70, 0x2b, 0x60, 0xd0, 0x19, 0x97,
	0xf9, 0xab, 0x5d, 0x16, 0x96, 0x5d, 0x1e, 0x3e, 0x20, 0xc5, 0xa4, 0x29, 0x29, 0x21, 0x3b, 0x83,
	0xee, 0x9b, 0x57, 0xa3, 0x93, 0xea, 0x16, 0xdd, 0x25, 0xa5, 0x4e, 0x6b, 0xd8, 0x1d, 0xf6, 0x4e,
	0xba, 0xd5, 0xdc, 0xe1, 0x8f, 0x8b, 0xa6, 0x42, 0x62, 0x91, 0x14, 0x9e, 0x77, 0x87, 0xd5, 0x2d,
	0x5a, 0x22, 0xd7, 0x5e, 0x74, 0x5b, 0x9d, 0x6a, 0x8e, 0xfe, 0x8f, 0x94, 0x9f, 0x8e, 0x7a, 0xfd,
	0x61, 0xef, 0xd5, 0xf1, 0xa0, 0x9a, 0xa7, 0x15, 0x52, 0x3c, 0x1e, 0xb4, 0xad, 0xde, 0xe9, 0xb0,
	0x5a, 0x38, 0xfa, 0x3d, 0x4f, 0x2a, 0x3d, 0x07, 0x78, 0xdb, 0xfc, 0xc6, 0xd1, 0x2e, 0xa1, 0x2d,
	0xc7, 0x31, 0x4b, 0xac, 0x15, 0x38, 0x3a, 0x1d, 0x08, 0xe8, 0xad, 0x6c, 0x91, 0x16, 0x7f, 0x52,
	0x07, 0x37, 0x57, 0x7b, 0x50, 0xb7, 0x43, 0x7d, 0xeb, 0xab, 0x1c, 0xfd, 0x81, 0x94, 0x5a, 0x8e,
	0xa3, 0xa1, 0x88, 0x6e, 0xea, 0x54, 0xdd, 0xff, 0x07, 0x74, 0xa9, 0xf4, 0x58, 0xb9, 0xfa, 0x56,
	0x43, 0x5f, 0x2e, 0xb7, 0x71, 0x5a, 0x1d, 0x8b, 0x31, 0xbd, 0xb2, 0x3f, 0x36, 0x5f, 0xa7, 0x1d,
	0xb2, 0xff, 0x1c, 0x54, 0x2b, 0xe0, 0xde, 0xfc, 0x03, 0x38, 0x23, 0xab, 0x1f, 0xfd, 0x83, 0x89,
	0xa5, 0xef, 0x3f, 0xa9, 0x9e, 0x8e, 0x7f, 0xbc, 0x83, 0xf8, 0xe3, 0xbf, 0x03, 0x00, 0x00, 0xff,
	0xff, 0xfa, 0x0f, 0xc0, 0x9a, 0xee, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// IdeaCrawlerClient is the client API for IdeaCrawler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IdeaCrawlerClient interface {
	AddDomainAndListen(ctx context.Context, in *DomainOpt, opts ...grpc.CallOption) (IdeaCrawler_AddDomainAndListenClient, error)
	AddPages(ctx context.Context, opts ...grpc.CallOption) (IdeaCrawler_AddPagesClient, error)
	CancelJob(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Status, error)
	GetAnalyzedURLs(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (IdeaCrawler_GetAnalyzedURLsClient, error)
}

type ideaCrawlerClient struct {
	cc *grpc.ClientConn
}

func NewIdeaCrawlerClient(cc *grpc.ClientConn) IdeaCrawlerClient {
	return &ideaCrawlerClient{cc}
}

func (c *ideaCrawlerClient) AddDomainAndListen(ctx context.Context, in *DomainOpt, opts ...grpc.CallOption) (IdeaCrawler_AddDomainAndListenClient, error) {
	stream, err := c.cc.NewStream(ctx, &_IdeaCrawler_serviceDesc.Streams[0], "/protofiles.IdeaCrawler/AddDomainAndListen", opts...)
	if err != nil {
		return nil, err
	}
	x := &ideaCrawlerAddDomainAndListenClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IdeaCrawler_AddDomainAndListenClient interface {
	Recv() (*PageHTML, error)
	grpc.ClientStream
}

type ideaCrawlerAddDomainAndListenClient struct {
	grpc.ClientStream
}

func (x *ideaCrawlerAddDomainAndListenClient) Recv() (*PageHTML, error) {
	m := new(PageHTML)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ideaCrawlerClient) AddPages(ctx context.Context, opts ...grpc.CallOption) (IdeaCrawler_AddPagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_IdeaCrawler_serviceDesc.Streams[1], "/protofiles.IdeaCrawler/AddPages", opts...)
	if err != nil {
		return nil, err
	}
	x := &ideaCrawlerAddPagesClient{stream}
	return x, nil
}

type IdeaCrawler_AddPagesClient interface {
	Send(*PageRequest) error
	CloseAndRecv() (*Status, error)
	grpc.ClientStream
}

type ideaCrawlerAddPagesClient struct {
	grpc.ClientStream
}

func (x *ideaCrawlerAddPagesClient) Send(m *PageRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *ideaCrawlerAddPagesClient) CloseAndRecv() (*Status, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Status)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ideaCrawlerClient) CancelJob(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/protofiles.IdeaCrawler/CancelJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ideaCrawlerClient) GetAnalyzedURLs(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (IdeaCrawler_GetAnalyzedURLsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_IdeaCrawler_serviceDesc.Streams[2], "/protofiles.IdeaCrawler/GetAnalyzedURLs", opts...)
	if err != nil {
		return nil, err
	}
	x := &ideaCrawlerGetAnalyzedURLsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IdeaCrawler_GetAnalyzedURLsClient interface {
	Recv() (*UrlList, error)
	grpc.ClientStream
}

type ideaCrawlerGetAnalyzedURLsClient struct {
	grpc.ClientStream
}

func (x *ideaCrawlerGetAnalyzedURLsClient) Recv() (*UrlList, error) {
	m := new(UrlList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IdeaCrawlerServer is the server API for IdeaCrawler service.
type IdeaCrawlerServer interface {
	AddDomainAndListen(*DomainOpt, IdeaCrawler_AddDomainAndListenServer) error
	AddPages(IdeaCrawler_AddPagesServer) error
	CancelJob(context.Context, *Subscription) (*Status, error)
	GetAnalyzedURLs(*Subscription, IdeaCrawler_GetAnalyzedURLsServer) error
}

func RegisterIdeaCrawlerServer(s *grpc.Server, srv IdeaCrawlerServer) {
	s.RegisterService(&_IdeaCrawler_serviceDesc, srv)
}

func _IdeaCrawler_AddDomainAndListen_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DomainOpt)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IdeaCrawlerServer).AddDomainAndListen(m, &ideaCrawlerAddDomainAndListenServer{stream})
}

type IdeaCrawler_AddDomainAndListenServer interface {
	Send(*PageHTML) error
	grpc.ServerStream
}

type ideaCrawlerAddDomainAndListenServer struct {
	grpc.ServerStream
}

func (x *ideaCrawlerAddDomainAndListenServer) Send(m *PageHTML) error {
	return x.ServerStream.SendMsg(m)
}

func _IdeaCrawler_AddPages_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(IdeaCrawlerServer).AddPages(&ideaCrawlerAddPagesServer{stream})
}

type IdeaCrawler_AddPagesServer interface {
	SendAndClose(*Status) error
	Recv() (*PageRequest, error)
	grpc.ServerStream
}

type ideaCrawlerAddPagesServer struct {
	grpc.ServerStream
}

func (x *ideaCrawlerAddPagesServer) SendAndClose(m *Status) error {
	return x.ServerStream.SendMsg(m)
}

func (x *ideaCrawlerAddPagesServer) Recv() (*PageRequest, error) {
	m := new(PageRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _IdeaCrawler_CancelJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdeaCrawlerServer).CancelJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protofiles.IdeaCrawler/CancelJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdeaCrawlerServer).CancelJob(ctx, req.(*Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdeaCrawler_GetAnalyzedURLs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IdeaCrawlerServer).GetAnalyzedURLs(m, &ideaCrawlerGetAnalyzedURLsServer{stream})
}

type IdeaCrawler_GetAnalyzedURLsServer interface {
	Send(*UrlList) error
	grpc.ServerStream
}

type ideaCrawlerGetAnalyzedURLsServer struct {
	grpc.ServerStream
}

func (x *ideaCrawlerGetAnalyzedURLsServer) Send(m *UrlList) error {
	return x.ServerStream.SendMsg(m)
}

var _IdeaCrawler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protofiles.IdeaCrawler",
	HandlerType: (*IdeaCrawlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CancelJob",
			Handler:    _IdeaCrawler_CancelJob_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AddDomainAndListen",
			Handler:       _IdeaCrawler_AddDomainAndListen_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AddPages",
			Handler:       _IdeaCrawler_AddPages_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetAnalyzedURLs",
			Handler:       _IdeaCrawler_GetAnalyzedURLs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protofiles/ideacrawler.proto",
}
